"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CARDANO_CHIMERIC = exports.CARDANO_CHANGE = exports.CARDANO_EXTERNAL = exports.CARDANO_COIN_TYPE = exports.CARDANO_PUROPOSE = exports.MetadateTypesEnum = exports.Bip32KeyPair = exports.Seed = void 0;
var bip39_1 = require("bip39");
var cardano_serialization_lib_nodejs_1 = require("@emurgo/cardano-serialization-lib-nodejs");
var config_1 = require("./config");
var phrasesLengthMap = {
    12: 128,
    15: 160,
    18: 192,
    21: 224,
    24: 256
};
var Seed = /** @class */ (function () {
    function Seed() {
    }
    Seed.generateRecoveryPhrase = function (size) {
        if (size === void 0) { size = 15; }
        var strength = phrasesLengthMap[size] || phrasesLengthMap[15];
        return bip39_1.generateMnemonic(strength).trim();
    };
    Seed.toMnemonicList = function (phrase) {
        return phrase.trim().split(/\s+/g);
    };
    Seed.deriveRootKey = function (phrase) {
        var mnemonic = Array.isArray(phrase) ? phrase.join(" ") : phrase;
        var entropy = bip39_1.mnemonicToEntropy(mnemonic);
        var rootKey = cardano_serialization_lib_nodejs_1.Bip32PrivateKey.from_bip39_entropy(Buffer.from(entropy, 'hex'), Buffer.from(''));
        return rootKey;
    };
    Seed.deriveAccountKey = function (key, index) {
        if (index === void 0) { index = 0; }
        return key
            .derive(Seed.harden(exports.CARDANO_PUROPOSE)) // purpose
            .derive(Seed.harden(exports.CARDANO_COIN_TYPE)) // coin type
            .derive(Seed.harden(index)); // account #0
    };
    Seed.deriveKey = function (key, path) {
        var result = key;
        path.forEach(function (p) {
            result = result.derive(p.endsWith('H') || p.endsWith("'")
                ? Seed.harden(Number.parseInt(p.substr(0, p.length - 1)))
                : Number.parseInt(p));
        });
        return result;
    };
    Seed.buildTransaction = function (coinSelection, ttl, opts) {
        var _a, _b;
        if (opts === void 0) { opts = { changeAddress: "", metadata: null, startSlot: 0, config: config_1.Config.Mainnet }; }
        var config = opts.config || config_1.Config.Mainnet;
        var metadata = opts.metadata;
        var startSlot = opts.startSlot || 0;
        var txBuilder = cardano_serialization_lib_nodejs_1.TransactionBuilder.new(
        // all of these are taken from the mainnet genesis settings
        // linear fee parameters (a*size + b)
        cardano_serialization_lib_nodejs_1.LinearFee.new(cardano_serialization_lib_nodejs_1.BigNum.from_str(config.protocolParams.minFeeA.toString()), cardano_serialization_lib_nodejs_1.BigNum.from_str(config.protocolParams.minFeeB.toString())), 
        // minimum utxo value
        cardano_serialization_lib_nodejs_1.BigNum.from_str(config.protocolParams.minUTxOValue.toString()), 
        // pool deposit
        cardano_serialization_lib_nodejs_1.BigNum.from_str(config.protocolParams.poolDeposit.toString()), 
        // key deposit
        cardano_serialization_lib_nodejs_1.BigNum.from_str(config.protocolParams.keyDeposit.toString()));
        // add tx inputs
        coinSelection.inputs.forEach(function (input, i) {
            var address = cardano_serialization_lib_nodejs_1.Address.from_bech32(input.address);
            var txInput = cardano_serialization_lib_nodejs_1.TransactionInput.new(cardano_serialization_lib_nodejs_1.TransactionHash.from_bytes(Buffer.from(input.id, 'hex')), input.index);
            var amount = cardano_serialization_lib_nodejs_1.Value.new(cardano_serialization_lib_nodejs_1.BigNum.from_str(input.amount.quantity.toString()));
            txBuilder.add_input(address, txInput, amount);
        });
        // add tx outputs
        coinSelection.outputs.forEach(function (output) {
            var address = cardano_serialization_lib_nodejs_1.Address.from_bech32(output.address);
            var amount = cardano_serialization_lib_nodejs_1.Value.new(cardano_serialization_lib_nodejs_1.BigNum.from_str(output.amount.quantity.toString()));
            // add tx assets
            if (output.assets && output.assets.length > 0) {
                var multiAsset = Seed.buildMultiAssets(output.assets);
                amount.set_multiasset(multiAsset);
            }
            var txOutput = cardano_serialization_lib_nodejs_1.TransactionOutput.new(address, amount);
            txBuilder.add_output(txOutput);
        });
        // add tx change
        coinSelection.change.forEach(function (change) {
            var address = cardano_serialization_lib_nodejs_1.Address.from_bech32(change.address);
            var amount = cardano_serialization_lib_nodejs_1.Value.new(cardano_serialization_lib_nodejs_1.BigNum.from_str(change.amount.quantity.toString()));
            // add tx assets
            if (change.assets && change.assets.length > 0) {
                var multiAsset = Seed.buildMultiAssets(change.assets);
                amount.set_multiasset(multiAsset);
            }
            var txOutput = cardano_serialization_lib_nodejs_1.TransactionOutput.new(address, amount);
            txBuilder.add_output(txOutput);
        });
        // add tx metadata
        if (metadata) {
            txBuilder.set_metadata(metadata);
        }
        // set tx validity start interval
        txBuilder.set_validity_start_interval(startSlot);
        // set tx ttl
        txBuilder.set_ttl(ttl);
        // calculate fee
        if (opts.changeAddress) { // don't take the implicit fee
            var address = cardano_serialization_lib_nodejs_1.Address.from_bech32(opts.changeAddress);
            txBuilder.add_change_if_needed(address);
        }
        else {
            var fee = coinSelection.inputs.reduce(function (acc, c) { return c.amount.quantity + acc; }, 0)
                + (((_a = coinSelection.withdrawals) === null || _a === void 0 ? void 0 : _a.reduce(function (acc, c) { return c.amount.quantity + acc; }, 0)) || 0)
                - coinSelection.outputs.reduce(function (acc, c) { return c.amount.quantity + acc; }, 0)
                - coinSelection.change.reduce(function (acc, c) { return c.amount.quantity + acc; }, 0)
                - (((_b = coinSelection.deposits) === null || _b === void 0 ? void 0 : _b.reduce(function (acc, c) { return c.quantity + acc; }, 0)) || 0);
            txBuilder.set_fee(cardano_serialization_lib_nodejs_1.BigNum.from_str(fee.toString()));
        }
        var txBody = txBuilder.build();
        return txBody;
    };
    Seed.buildTransactionWithToken = function (coinSelection, ttl, tokens, signingKeys, opts) {
        if (opts === void 0) { opts = { changeAddress: "", data: null, startSlot: 0, config: config_1.Config.Mainnet }; }
        var metadata = opts.data ? Seed.buildTransactionMetadata(opts.data) : null;
        opts.config = opts.config || config_1.Config.Mainnet;
        var buildOpts = Object.assign({}, __assign({ metadata: metadata }, opts));
        // create mint token data
        var mint = Seed.buildTransactionMint(tokens);
        // get token's scripts 
        var scripts = tokens.map(function (t) { return t.script; });
        // set mint into tx
        var txBody = Seed.buildTransaction(coinSelection, ttl, buildOpts);
        txBody.set_mint(mint);
        // tx field fee
        var fieldFee = parseInt(txBody.fee().to_str());
        // sign to calculate the real tx fee;
        var tx = Seed.sign(txBody, signingKeys, metadata, scripts);
        // NOTE: new fee should be equal to txFee after changed since we're only rearranging the tx bytes 
        // the marginFee value between the change utxo and the fee field;
        var txFee = parseInt(Seed.getTransactionFee(tx, opts.config).to_str());
        var marginFee = txFee - fieldFee; // if < 0 the current fee is enough, so we won't burn the dust!
        // get the change UTXO from where adjust the quantity
        var index = marginFee <= 0 ? 0 : coinSelection.change.findIndex(function (c) {
            var minAda = Seed.getMinUtxoValueWithAssets(c.assets, opts.config, 'hex');
            return c.amount.quantity - marginFee >= minAda;
        });
        if (index < 0) {
            throw new Error("Not enough money for minting :(");
        }
        var quantity = coinSelection.change[index].amount.quantity;
        coinSelection.change[index].amount.quantity = quantity - marginFee;
        // after signing the metadata is cleaned so we need to create it again
        metadata = opts.data ? Seed.buildTransactionMetadata(opts.data) : null;
        buildOpts = Object.assign({}, __assign({ metadata: metadata }, opts));
        txBody = Seed.buildTransaction(coinSelection, ttl, buildOpts);
        txBody.set_mint(mint);
        return txBody;
    };
    Seed.buildMultiAssets = function (assets) {
        var multiAsset = cardano_serialization_lib_nodejs_1.MultiAsset.new();
        assets.forEach(function (a) {
            var asset = cardano_serialization_lib_nodejs_1.Assets.new();
            var scriptHash = Seed.getScriptHashFromPolicy(a.policy_id);
            asset.insert(cardano_serialization_lib_nodejs_1.AssetName.new(Buffer.from(a.asset_name, 'hex')), cardano_serialization_lib_nodejs_1.BigNum.from_str(a.quantity.toString()));
            multiAsset.insert(scriptHash, asset);
        });
        return multiAsset;
    };
    Seed.buildTransactionMint = function (tokens) {
        var mint = cardano_serialization_lib_nodejs_1.Mint.new();
        tokens.forEach(function (t) {
            var mintAssets = cardano_serialization_lib_nodejs_1.MintAssets.new();
            var scriptHash = Seed.getScriptHashFromPolicy(t.asset.policy_id);
            mintAssets.insert(cardano_serialization_lib_nodejs_1.AssetName.new(Buffer.from(t.asset.asset_name)), cardano_serialization_lib_nodejs_1.Int.new_i32(t.asset.quantity));
            mint.insert(scriptHash, mintAssets);
        });
        return mint;
    };
    Seed.getTransactionFee = function (tx, config) {
        if (config === void 0) { config = config_1.Config.Mainnet; }
        return cardano_serialization_lib_nodejs_1.min_fee(tx, cardano_serialization_lib_nodejs_1.LinearFee.new(cardano_serialization_lib_nodejs_1.BigNum.from_str(config.protocolParams.minFeeA.toString()), cardano_serialization_lib_nodejs_1.BigNum.from_str(config.protocolParams.minFeeB.toString())));
    };
    Seed.sign = function (txBody, privateKeys, transactionMetadata, scripts) {
        var txHash = cardano_serialization_lib_nodejs_1.hash_transaction(txBody);
        var witnesses = cardano_serialization_lib_nodejs_1.TransactionWitnessSet.new();
        var vkeyWitnesses = cardano_serialization_lib_nodejs_1.Vkeywitnesses.new();
        privateKeys.forEach(function (prvKey) {
            // add keyhash witnesses
            var vkeyWitness = cardano_serialization_lib_nodejs_1.make_vkey_witness(txHash, prvKey);
            vkeyWitnesses.add(vkeyWitness);
        });
        witnesses.set_vkeys(vkeyWitnesses);
        if (scripts) {
            var nativeScripts_1 = cardano_serialization_lib_nodejs_1.NativeScripts.new();
            scripts.forEach(function (s) {
                nativeScripts_1.add(s);
            });
            witnesses.set_scripts(nativeScripts_1);
        }
        var transaction = cardano_serialization_lib_nodejs_1.Transaction.new(txBody, witnesses, transactionMetadata);
        return transaction;
    };
    Seed.signMessage = function (key, message) {
        return key.sign(Buffer.from(message)).to_hex();
    };
    Seed.verifyMessage = function (key, message, signed) {
        return key.verify(Buffer.from(message), cardano_serialization_lib_nodejs_1.Ed25519Signature.from_hex(signed));
    };
    Seed.harden = function (num) {
        return 0x80000000 + num;
    };
    Seed.constructMetadata = function (data) {
        var metadata = {};
        if (Array.isArray(data)) {
            for (var i = 0; i < data.length; i++) {
                var value = data[i];
                metadata[i] = Seed.getMetadataObject(value);
            }
        }
        else {
            var keys = Object.keys(data);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (this.isInteger(key)) {
                    var index = parseInt(key);
                    metadata[index] = Seed.getMetadataObject(data[key]);
                }
            }
        }
        return metadata;
    };
    Seed.getMetadataObject = function (data) {
        var _this = this;
        var result = {};
        var type = typeof data;
        if (type == "number") {
            result[MetadateTypesEnum.Number] = data;
        }
        else if (type == "string" && Buffer.byteLength(data, 'utf-8') <= 64) {
            result[MetadateTypesEnum.String] = data;
        }
        else if (Buffer.isBuffer(data) && Buffer.byteLength(data, "hex") <= 64) {
            result[MetadateTypesEnum.Bytes] = data.toString("hex");
        }
        else if (type == "boolean") {
            result[MetadateTypesEnum.String] = data.toString();
        }
        else if (type == "undefined") {
            result[MetadateTypesEnum.String] = "undefined";
        }
        else if (Array.isArray(data)) {
            result[MetadateTypesEnum.List] = data.map(function (a) { return _this.getMetadataObject(a); });
        }
        else if (type == "object") {
            if (data) {
                result[MetadateTypesEnum.Map] = Object.keys(data).map(function (k) {
                    return {
                        "k": _this.getMetadataObject(k),
                        "v": _this.getMetadataObject(data[k])
                    };
                });
            }
            else {
                result[MetadateTypesEnum.String] = "null";
            }
        }
        return result;
    };
    Seed.reverseMetadata = function (data, type) {
        if (type === void 0) { type = "object"; }
        if (!data) {
            return null;
        }
        var metadata = type == "object" ? {} : [];
        var keys = Object.keys(data);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var index = parseInt(key);
            metadata[index] = Seed.reverseMetadataObject(data[key]);
        }
        return metadata;
    };
    Seed.reverseMetadataObject = function (data) {
        var result = [];
        var keys = Object.keys(data);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = data[key];
            if (key == "string") {
                result.push(value);
            }
            else if (key == "int") {
                result.push(new Number(value));
            }
            else if (key == "bytes") {
                result.push(Buffer.from(value, 'hex'));
            }
            else if (key == "list") {
                result.push(value.map(function (d) { return Seed.reverseMetadataObject(d); }));
            }
            else if (key == "map") {
                var map = value.reduce(function (acc, obj) {
                    var k = Seed.reverseMetadataObject(obj["k"]);
                    var v = Seed.reverseMetadataObject(obj["v"]);
                    acc[k] = v;
                    return acc;
                }, {});
                result.push(map);
            }
            else {
                result.push(null);
            }
        }
        return result.length == 1 ? result[0] : result;
    };
    Seed.buildTransactionMetadata = function (data) {
        var metadata = Seed.constructMetadata(data);
        var generalMetatada = cardano_serialization_lib_nodejs_1.GeneralTransactionMetadata.new();
        for (var key in metadata) {
            var value = metadata[key];
            generalMetatada.insert(cardano_serialization_lib_nodejs_1.BigNum.from_str(key), Seed.getTransactionMetadatum(value));
        }
        return cardano_serialization_lib_nodejs_1.TransactionMetadata.new(generalMetatada);
    };
    Seed.getTransactionMetadatum = function (value) {
        if (value.hasOwnProperty(MetadateTypesEnum.Number)) {
            return cardano_serialization_lib_nodejs_1.TransactionMetadatum.new_int(cardano_serialization_lib_nodejs_1.Int.new_i32(value[MetadateTypesEnum.Number]));
        }
        if (value.hasOwnProperty(MetadateTypesEnum.String)) {
            return cardano_serialization_lib_nodejs_1.TransactionMetadatum.new_text(value[MetadateTypesEnum.String]);
        }
        if (value.hasOwnProperty(MetadateTypesEnum.Bytes)) {
            return cardano_serialization_lib_nodejs_1.TransactionMetadatum.new_bytes(Buffer.from(value[MetadateTypesEnum.Bytes], 'hex'));
        }
        if (value.hasOwnProperty(MetadateTypesEnum.List)) {
            var list = value[MetadateTypesEnum.List];
            var metalist = cardano_serialization_lib_nodejs_1.MetadataList.new();
            for (var i = 0; i < list.length; i++) {
                metalist.add(Seed.getTransactionMetadatum(list[i]));
            }
            return cardano_serialization_lib_nodejs_1.TransactionMetadatum.new_list(metalist);
        }
        if (value.hasOwnProperty(MetadateTypesEnum.Map)) {
            var map = value[MetadateTypesEnum.Map];
            var metamap = cardano_serialization_lib_nodejs_1.MetadataMap.new();
            for (var i = 0; i < map.length; i++) {
                var _a = map[i], k = _a.k, v = _a.v;
                metamap.insert(Seed.getTransactionMetadatum(k), Seed.getTransactionMetadatum(v));
            }
            return cardano_serialization_lib_nodejs_1.TransactionMetadatum.new_map(metamap);
        }
    };
    Seed.generateKeyPair = function () {
        var prvKey = cardano_serialization_lib_nodejs_1.Bip32PrivateKey.generate_ed25519_bip32();
        var pubKey = prvKey.to_public();
        var pair = {
            privateKey: prvKey,
            publicKey: pubKey
        };
        return pair;
    };
    // enterprise address without staking ability, for use by exchanges/etc
    Seed.generateEnterpriseAddress = function (pubKey, network) {
        if (network === void 0) { network = 'mainnet'; }
        var networkId = network == 'mainnet' ? cardano_serialization_lib_nodejs_1.NetworkInfo.mainnet().network_id() : cardano_serialization_lib_nodejs_1.NetworkInfo.testnet().network_id();
        return cardano_serialization_lib_nodejs_1.EnterpriseAddress.new(networkId, cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(pubKey.to_raw_key().hash())).to_address();
    };
    Seed.getKeyHash = function (key) {
        return key.to_raw_key().hash();
    };
    Seed.buildSingleIssuerScript = function (keyHash) {
        var scriptPubKey = cardano_serialization_lib_nodejs_1.ScriptPubkey.new(keyHash);
        return cardano_serialization_lib_nodejs_1.NativeScript.new_script_pubkey(scriptPubKey);
    };
    Seed.buildMultiIssuerAllScript = function (scripts) {
        var nativeScripts = this.buildNativeScripts(scripts);
        var scriptAll = cardano_serialization_lib_nodejs_1.ScriptAll.new(nativeScripts);
        return cardano_serialization_lib_nodejs_1.NativeScript.new_script_all(scriptAll);
    };
    Seed.buildMultiIssuerAnyScript = function (scripts) {
        var nativeScripts = this.buildNativeScripts(scripts);
        var scriptAny = cardano_serialization_lib_nodejs_1.ScriptAny.new(nativeScripts);
        return cardano_serialization_lib_nodejs_1.NativeScript.new_script_any(scriptAny);
    };
    Seed.buildMultiIssuerAtLeastScript = function (n, scripts) {
        var nativeScripts = this.buildNativeScripts(scripts);
        var scriptAtLeast = cardano_serialization_lib_nodejs_1.ScriptNOfK.new(n, nativeScripts);
        return cardano_serialization_lib_nodejs_1.NativeScript.new_script_n_of_k(scriptAtLeast);
    };
    // you need to set validity range on transcation builder to check on a deterministic way
    Seed.buildAfterScript = function (slot) {
        var scriptAfter = cardano_serialization_lib_nodejs_1.TimelockStart.new(slot);
        return cardano_serialization_lib_nodejs_1.NativeScript.new_timelock_start(scriptAfter);
    };
    // you need to set validity range on transcation builder to check on a deterministic way
    Seed.buildBeforeScript = function (slot) {
        var scriptBefore = cardano_serialization_lib_nodejs_1.TimelockExpiry.new(slot);
        return cardano_serialization_lib_nodejs_1.NativeScript.new_timelock_expiry(scriptBefore);
    };
    Seed.buildNativeScripts = function (scripts) {
        var nativeScripts = cardano_serialization_lib_nodejs_1.NativeScripts.new();
        scripts.forEach(function (script) {
            nativeScripts.add(script);
        });
        return nativeScripts;
    };
    Seed.getScriptHash = function (script) {
        var keyHash = script.hash(cardano_serialization_lib_nodejs_1.ScriptHashNamespace.NativeScript);
        var scriptHash = cardano_serialization_lib_nodejs_1.ScriptHash.from_bytes(keyHash.to_bytes());
        return scriptHash;
        // let credential = StakeCredential.from_keyhash(keyHash);
        // return credential.to_scripthash();
    };
    Seed.getPolicyId = function (scriptHash) {
        return Buffer.from(scriptHash.to_bytes()).toString('hex');
    };
    Seed.getScriptHashFromPolicy = function (policyId) {
        return cardano_serialization_lib_nodejs_1.ScriptHash.from_bytes(Buffer.from(policyId, 'hex'));
    };
    Seed.getMinUtxoValueWithAssets = function (tokenAssets, config, encoding) {
        if (config === void 0) { config = config_1.Config.Mainnet; }
        if (encoding === void 0) { encoding = 'utf8'; }
        var assets = cardano_serialization_lib_nodejs_1.Value.new(cardano_serialization_lib_nodejs_1.BigNum.from_str('1000000'));
        var multiAsset = cardano_serialization_lib_nodejs_1.MultiAsset.new();
        tokenAssets.forEach(function (a) {
            var asset = cardano_serialization_lib_nodejs_1.Assets.new();
            var assetName = a.asset_name;
            var quantity = a.quantity.toString();
            var scriptHash = Seed.getScriptHashFromPolicy(a.policy_id);
            asset.insert(cardano_serialization_lib_nodejs_1.AssetName.new(Buffer.from(assetName, encoding)), cardano_serialization_lib_nodejs_1.BigNum.from_str(quantity));
            multiAsset.insert(scriptHash, asset);
        });
        assets.set_multiasset(multiAsset);
        var min = cardano_serialization_lib_nodejs_1.min_ada_required(assets, cardano_serialization_lib_nodejs_1.BigNum.from_str(config.protocolParams.minUTxOValue.toString()));
        return Number.parseInt(min.to_str());
    };
    Seed.isInteger = function (value) {
        return Number.isInteger(Number(value));
    };
    return Seed;
}());
exports.Seed = Seed;
var Bip32KeyPair = /** @class */ (function () {
    function Bip32KeyPair() {
    }
    return Bip32KeyPair;
}());
exports.Bip32KeyPair = Bip32KeyPair;
var MetadateTypesEnum;
(function (MetadateTypesEnum) {
    MetadateTypesEnum["Number"] = "int";
    MetadateTypesEnum["String"] = "string";
    MetadateTypesEnum["Bytes"] = "bytes";
    MetadateTypesEnum["List"] = "list";
    MetadateTypesEnum["Map"] = "map";
})(MetadateTypesEnum = exports.MetadateTypesEnum || (exports.MetadateTypesEnum = {}));
exports.CARDANO_PUROPOSE = 1852;
exports.CARDANO_COIN_TYPE = 1815;
exports.CARDANO_EXTERNAL = 0;
exports.CARDANO_CHANGE = 1;
exports.CARDANO_CHIMERIC = 2;
